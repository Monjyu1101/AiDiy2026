# -*- coding: utf-8 -*-

"""
処理フロー整理結果まとめ

## 🎯 正しい処理フロー

### input_text処理
```
1. AI実行 + output_stream/output_text送信
2. バックアップ検証ループ（最大6回）
3. 生成ファイル通知
4. update_info送信
```

### input_request処理
```
1. チャンネル-1へ開始通知（音声付き）
2. input_text処理（上記1-4すべて実行）
3. output_request送信（チャンネル0へ）
4. チャンネル-1へ完了通知（音声付き）
```

## 📊 処理比較表

| 処理ステップ | input_text | input_request |
|--------------|------------|---------------|
| **チャンネル-1へ開始通知** | ❌ | ✅ 音声付き |
| **AI実行** | ✅ | ✅（input_text処理内） |
| **output_text送信** | ✅ | ✅（input_text処理内） |
| **バックアップ検証ループ** | ✅ 最大6回 | ✅（input_text処理内） |
| **生成ファイル通知** | ✅ | ✅（input_text処理内） |
| **update_info送信** | ✅ | ✅（input_text処理内） |
| **output_request送信** | ❌ | ✅ チャンネル0へ |
| **チャンネル-1へ完了通知** | ❌ | ✅ 音声付き |

## 🔧 コード構造

### 推奨構造
```python
async def _処理_input_text(self, 受信データ: dict):
    """input_text処理: 基本AI処理のみ"""
    await self._基本AI処理(受信データ)

async def _処理_input_request(self, 受信データ: dict):
    """input_request処理: 前後通知 + 基本AI処理 + output_request"""
    # 1. 開始通知（チャンネル-1）
    await self._チャンネルマイナス1通知("開始", メッセージ内容)
    
    # 2. 基本AI処理（input_text処理と同じ）
    出力メッセージ = await self._基本AI処理(受信データ)
    
    # 3. output_request送信（チャンネル0）
    await self._output_request送信(出力メッセージ)
    
    # 4. 完了通知（チャンネル-1）
    await self._チャンネルマイナス1通知("完了", メッセージ内容, 出力メッセージ)

async def _基本AI処理(self, 受信データ: dict) -> str:
    """基本AI処理（input_text/input_request共通）"""
    # 1. 添付ファイル追記
    # 2. AI実行
    # 3. output_text送信（自チャンネル）
    # 4. 会話履歴保存
    # 5. バックアップ検証ループ（最大6回）
    # 6. 生成ファイル通知
    # 7. update_info送信
    return 出力メッセージ内容
```

## 💡 重要なポイント

1. **input_requestはinput_textのラッパー**
   - input_text処理を完全に含む
   - 前後に通知と output_request を追加

2. **共通処理はすべて `_基本AI処理` に集約**
   - AI実行
   - バックアップ検証ループ
   - 生成ファイル通知
   - update_info送信

3. **input_request専用処理は3つだけ**
   - チャンネル-1へ開始通知
   - output_request送信
   - チャンネル-1へ完了通知

## 🎯 結論

**input_request = 開始通知 + input_text + output_request + 完了通知**

この構造により：
- コードの重複を完全に排除
- 処理の流れが明確
- メンテナンスが容易
"""
