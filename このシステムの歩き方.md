# このシステムの歩き方

## 本書の目的

このファイルは **AiDiy プロジェクトでの開発方法、コーディングルール、追加手順** を記載した開発者向けガイドです。

**対象読者：**
- AiDiyプロジェクトで実際にコードを書く開発者
- 新機能を追加する開発者
- コーディング規約を確認したい開発者

**関連ドキュメント：**
- **[./AGENTS.md](./AGENTS.md)** - プロジェクト全体方針（概要、アーキテクチャ、セットアップ）
- **[./CLAUDE.md](./CLAUDE.md)** - Claude Code向けインデックス（クイックスタート）
- **[./backend_server/AGENTS.md](./backend_server/AGENTS.md)** - バックエンド実装詳細
- **[./frontend_server/AGENTS.md](./frontend_server/AGENTS.md)** - フロントエンド実装詳細

**このファイルの内容：**
- コーディングルール（命名規則、フォーマット、コメント）
- 基本的な開発フロー
- 新規機能の追加手順（バックエンド/フロントエンド）
- ベストプラクティスとアンチパターン
- デバッグ方法
- コードレビューのポイント

---

## コーディングルール

### 命名規則

#### 1. 日本語命名の原則

**ビジネスドメインに関連する識別子は日本語を使用：**

```python
# ✅ 正解（バックエンド）
class C利用者(Base):
    __tablename__ = "C利用者"
    利用者ID = Column(String, primary_key=True)
    利用者名 = Column(String)
    パスワード = Column(String)
    権限ID = Column(String)

def get_C利用者_by_利用者ID(db: Session, 利用者ID: str):
    return db.query(models.C利用者).filter(models.C利用者.利用者ID == 利用者ID).first()
```

```vue
<!-- ✅ 正解（フロントエンド） -->
<script setup lang="ts">
const 利用者名 = ref('')
const 権限ID = ref('')

const 利用者一覧取得 = async () => {
  const response = await apiClient.post('/core/C利用者/一覧')
  return response.data.data.items
}
</script>
```

**システム/フレームワークに関連する識別子は英語を使用：**

```python
# ✅ 正解（バックエンド）
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

router = APIRouter(prefix="/core/C利用者", tags=["C利用者"])

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

```typescript
// ✅ 正解（フロントエンド）
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import apiClient from '@/api/client'

const router = useRouter()
const items = ref<any[]>([])
const loading = ref(false)
```

**一般的な変数名は英語を使用：**
- `request`, `response`, `query`, `params`
- `items`, `total`, `limit`, `offset`
- `data`, `error`, `status`, `message`
- `id`, `name`, `value`, `key`

#### 2. テーブル命名規則

**プレフィックスで分類：**
- `C` = Core/Common (C権限, C利用者, C採番)
- `M` = Master (M車両, M商品, M配車区分)
- `T` = Transaction (T配車, T商品入庫, T商品出庫, T商品棚卸)
- `V` = View (V利用者, V車両, V商品, V商品推移表)
- `S` = Scheduler/Special (S配車_週表示, S配車_日表示)
- `A` = AI/Advanced (AコアAI, A会話履歴)
- `X` = Experimental (Xテトリス, Xインベーダー)

**命名パターン：**
```
<プレフィックス><テーブル名>
例: C利用者, M商品, T配車
```

#### 3. API Endpoint命名規則

**バックエンド：**
```python
# ✅ 正解
@router.post("/一覧")          # 一覧取得
@router.post("/取得")           # 1件取得
@router.post("/登録")        # 作成
@router.post("/変更")        # 更新
@router.post("/削除")        # 削除

# ❌ 誤り（GET/PUT/削除メソッドは使わない）
@router.get("/一覧")
@router.put("/変更")
@router.delete("/削除")
```

**フロントエンド（ルート）：**
```typescript
// ✅ 正解
{
  path: '/C管理/C利用者/一覧',
  name: 'C利用者一覧',
  component: () => import('@/components/C管理/C利用者/C利用者一覧.vue')
}
```

#### 4. Vue Component命名規則

**ファイル名は日本語OK：**
```
✅ C利用者一覧.vue
✅ M商品編集.vue
✅ _Layout.vue
✅ _TopBar.vue
```

**Component タグは ASCII 名のみ：**
```vue
<!-- ❌ 誤り（日本語タグ名は無効） -->
<C利用者一覧 />

<!-- ✅ 正解（動的コンポーネント） -->
<component :is="C利用者一覧" />

<!-- ✅ 正解（英語エイリアス） -->
<script setup>
import C利用者一覧 from './C利用者一覧.vue'
</script>
<template>
  <user-list />  <!-- kebab-case -->
</template>
```

#### 5. 変数命名のケース

**バックエンド（Python）：**
- 関数名: `snake_case`（システム）、日本語（ビジネス）
- クラス名: `PascalCase`（システム）、日本語（ビジネス）
- 定数: `UPPER_SNAKE_CASE`

```python
# ✅ 正解
def get_C利用者_list(db: Session):
    pass

class C利用者(Base):
    pass

MAX_ITEMS = 10000
```

**フロントエンド（TypeScript）：**
- 変数名: `camelCase`（システム）、日本語（ビジネス）
- 関数名: `camelCase`（システム）、日本語（ビジネス）
- クラス名: `PascalCase`
- 定数: `UPPER_SNAKE_CASE` または `camelCase`

```typescript
// ✅ 正解
const 利用者名 = ref('')
const apiClient = axios.create({...})

function 利用者一覧取得() {
  // ...
}

class WebSocketManager {
  // ...
}

const MAX_RETRY_COUNT = 5
```

### ファイルエンコーディング

**必須：全ファイルは UTF-8 エンコーディング**

```bash
# Windows PowerShell でファイルのエンコーディング確認
Get-Content -Path ファイル名.py -Encoding UTF8

# VSCode設定（推奨）
"files.encoding": "utf8"
"files.autoGuessEncoding": false
```

### コメント規則

**バックエンド（Python）：**

```python
# ✅ 正解（日本語コメント）
def get_C利用者_list(db: Session):
    """利用者の一覧を取得する

    Args:
        db: データベースセッション

    Returns:
        利用者のリスト
    """
    # パスワードは除外して返す
    return db.query(models.C利用者).all()
```

**フロントエンド（TypeScript）：**

```typescript
// ✅ 正解（日本語コメント）
/**
 * 利用者一覧を取得する
 * @returns 利用者の配列
 */
const 利用者一覧取得 = async () => {
  // API呼び出し
  const response = await apiClient.post('/core/C利用者/一覧')
  return response.data.data.items
}
```

### インデント規則

**バックエンド（Python）：**
- インデント: 4スペース
- タブは使用しない

**フロントエンド（TypeScript/Vue）：**
- インデント: 2スペース
- タブは使用しない

---

## 基本的な開発フロー

### 1. 環境セットアップ

```bash
# 1. リポジトリクローン
git clone <repository-url>
cd AiDiy_next

# 2. バックエンド依存関係インストール
cd backend_server
uv sync

# 3. フロントエンド依存関係インストール
cd ../frontend_server
npm install

# 4. プロジェクトルートに戻る
cd ..

# 5. 起動
python _start.py
```

### 2. 開発サイクル

```
1. 機能設計
   ↓
2. バックエンド実装（テーブル → CRUD → API）
   ↓
3. フロントエンド実装（画面 → API連携）
   ↓
4. テスト（手動）
   ↓
5. コミット
```

### 3. Git コミットフロー

```bash
# 1. 現在の状態確認
git status
git diff

# 2. 変更をステージング（特定ファイルのみ）
git add backend_server/routers1/C利用者.py
git add frontend_server/src/components/C管理/C利用者/

# 3. コミット（日本語コミットメッセージOK）
git commit -m "C利用者管理画面を追加

- C利用者の一覧表示機能
- C利用者の編集機能（新規/更新）
- qTublerテーブルによる一覧表示

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# 4. プッシュ（必要に応じて）
git push origin main
```

---

## 実装確認済みの注意点（間違いやすいポイント）

- **バックエンドのリロード**: `_start.py` で起動したバックエンドは `uvicorn --reload` が付かないため自動リロードされません。変更反映は再起動、または `backend_server/temp/reboot1.txt` / `reboot2.txt` の作成で行います。
- **初期データの投入条件**: `crud1.init_db_data()` は **admin が未存在のときのみ** C利用者を投入します。既存DBに admin がいる場合は自動で更新されません。
- **DBファイルの場所**: SQLite は `backend_server/_data/AiDiy/database.db` に作成され、main1 / main2 で共有されます。
- **Vite Proxy 前提**: フロントエンドは `baseURL='/'` を前提に `/core` と `/apps` を Vite Proxy に流します。ポート変更時は `vite.config.ts` と backend の CORS 許可リストを必ず更新してください。
- **_setup.py の表示**: セットアップ完了メッセージに `python start.py` と表示されますが、実際の起動は **`python _start.py`** です。

---

## 新規機能の追加手順

### バックエンド：新規テーブルの追加

#### C系/A系テーブルの場合（main1.py）

**1. モデルを作成 (`backend_server/models1/<テーブル名>.py`)**

```python
# -*- coding: utf-8 -*-
from sqlalchemy import Column, String, Integer
from database import Base

class C新テーブル(Base):
    __tablename__ = "C新テーブル"

    # 主キー
    新ID = Column(String, primary_key=True)
    新名 = Column(String, nullable=False)
    新備考 = Column(String)

    # 監査フィールド（必須）
    登録日時 = Column(String, nullable=False)
    登録利用者ID = Column(String, nullable=False)
    登録利用者名 = Column(String)
    登録端末ID = Column(String, nullable=False)
    更新日時 = Column(String, nullable=False)
    更新利用者ID = Column(String, nullable=False)
    更新利用者名 = Column(String)
    更新端末ID = Column(String, nullable=False)
```

**2. モデルをエクスポート (`backend_server/models1/__init__.py`)**

```python
from .C新テーブル import C新テーブル
```

**3. Pydantic スキーマを追加 (`backend_server/schemas.py`)**

```python
class C新テーブルBase(BaseModel):
    新名: str
    新備考: Optional[str] = None

class C新テーブルCreate(C新テーブルBase):
    新ID: str

class C新テーブルUpdate(BaseModel):
    新ID: str
    新名: Optional[str] = None
    新備考: Optional[str] = None

class C新テーブルDelete(BaseModel):
    新ID: str

class C新テーブルGet(BaseModel):
    新ID: str

class C新テーブル(C新テーブルBase):
    新ID: str
    登録日時: str
    登録利用者ID: str
    登録利用者名: Optional[str]
    登録端末ID: str
    更新日時: str
    更新利用者ID: str
    更新利用者名: Optional[str]
    更新端末ID: str

    class Config:
        from_attributes = True
```

**4. CRUD操作を作成 (`backend_server/crud1/C新テーブル.py`)**

```python
# -*- coding: utf-8 -*-
from sqlalchemy.orm import Session
import models1, schemas
from crud1.utils import create_audit_fields, update_audit_fields

def get_C新テーブル_list(db: Session):
    return db.query(models1.C新テーブル).all()

def get_C新テーブル_by_新ID(db: Session, 新ID: str):
    return db.query(models1.C新テーブル).filter(models1.C新テーブル.新ID == 新ID).first()

def create_C新テーブル(db: Session, 新テーブル: schemas.C新テーブルCreate, 認証情報: dict = None):
    監査項目 = create_audit_fields(認証情報)
    db_新テーブル = models1.C新テーブル(
        新ID=新テーブル.新ID,
        新名=新テーブル.新名,
        新備考=新テーブル.新備考,
        **監査項目
    )
    db.add(db_新テーブル)
    db.commit()
    db.refresh(db_新テーブル)
    return db_新テーブル

def update_C新テーブル(db: Session, 新ID: str, 新テーブル: schemas.C新テーブルUpdate, 認証情報: dict = None):
    db_新テーブル = get_C新テーブル_by_新ID(db, 新ID)
    if not db_新テーブル:
        return None

    if 新テーブル.新名 is not None:
        db_新テーブル.新名 = 新テーブル.新名
    if 新テーブル.新備考 is not None:
        db_新テーブル.新備考 = 新テーブル.新備考

    監査項目 = update_audit_fields(認証情報)
    for key, value in 監査項目.items():
        setattr(db_新テーブル, key, value)

    db.commit()
    db.refresh(db_新テーブル)
    return db_新テーブル

def delete_C新テーブル(db: Session, 新ID: str):
    db_新テーブル = get_C新テーブル_by_新ID(db, 新ID)
    if db_新テーブル:
        db.delete(db_新テーブル)
        db.commit()
    return db_新テーブル
```

**5. CRUDをエクスポート (`backend_server/crud1/__init__.py`)**

```python
from .C新テーブル import *
```

**6. ルーターを作成 (`backend_server/routers1/C新テーブル.py`)**

```python
# -*- coding: utf-8 -*-
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
import schemas, crud1 as crud, deps
from models1 import C利用者

router = APIRouter(prefix="/core/C新テーブル", tags=["C新テーブル"])

@router.post("/一覧", response_model=schemas.ResponseBase)
def read_C新テーブル_list(db: Session = Depends(deps.get_db), 現在利用者: C利用者 = Depends(deps.get_現在利用者)):
    items = crud.get_C新テーブル_list(db)
    return schemas.ResponseBase(
        status="OK",
        message="取得しました",
        data={"items": [schemas.C新テーブル.model_validate(item) for item in items], "total": len(items), "limit": 10000}
    )

@router.post("/取得", response_model=schemas.ResponseBase)
def read_C新テーブル(request: schemas.C新テーブルGet, db: Session = Depends(deps.get_db), 現在利用者: C利用者 = Depends(deps.get_現在利用者)):
    db_新テーブル = crud.get_C新テーブル_by_新ID(db, 新ID=request.新ID)
    if not db_新テーブル:
        return schemas.ResponseBase(status="NG", message="見つかりませんでした")
    return schemas.ResponseBase(
        status="OK",
        message="取得しました",
        data=schemas.C新テーブル.model_validate(db_新テーブル)
    )

@router.post("/登録", response_model=schemas.ResponseBase)
def create_C新テーブル(request: schemas.C新テーブルCreate, db: Session = Depends(deps.get_db), 現在利用者: C利用者 = Depends(deps.get_現在利用者)):
    認証情報 = {"利用者ID": 現在利用者.利用者ID, "利用者名": 現在利用者.利用者名}
    db_新テーブル = crud.create_C新テーブル(db, 新テーブル=request, 認証情報=認証情報)
    return schemas.ResponseBase(
        status="OK",
        message="作成しました",
        data=schemas.C新テーブル.model_validate(db_新テーブル)
    )

@router.post("/変更", response_model=schemas.ResponseBase)
def update_C新テーブル(request: schemas.C新テーブルUpdate, db: Session = Depends(deps.get_db), 現在利用者: C利用者 = Depends(deps.get_現在利用者)):
    認証情報 = {"利用者ID": 現在利用者.利用者ID, "利用者名": 現在利用者.利用者名}
    db_新テーブル = crud.update_C新テーブル(db, 新ID=request.新ID, 新テーブル=request, 認証情報=認証情報)
    if not db_新テーブル:
        return schemas.ResponseBase(status="NG", message="見つかりませんでした")
    return schemas.ResponseBase(
        status="OK",
        message="更新しました",
        data=schemas.C新テーブル.model_validate(db_新テーブル)
    )

@router.post("/削除", response_model=schemas.ResponseBase)
def delete_C新テーブル(request: schemas.C新テーブルDelete, db: Session = Depends(deps.get_db), 現在利用者: C利用者 = Depends(deps.get_現在利用者)):
    db_新テーブル = crud.delete_C新テーブル(db, 新ID=request.新ID)
    if not db_新テーブル:
        return schemas.ResponseBase(status="NG", message="見つかりませんでした")
    return schemas.ResponseBase(status="OK", message="削除しました")
```

**7. ルーターを登録 (`backend_server/main1.py`)**

```python
from routers1 import C新テーブル

app.include_router(C新テーブル.router)
```

**8. main1.pyに登録 (`backend_server/main1.py`)**

```python
# テーブル作成（core系のみ）
database.Base.metadata.create_all(
    bind=database.engine,
    tables=[
        models1.C採番.__table__,
        models1.C権限.__table__,
        models1.C利用者.__table__,
        models1.A会話履歴.__table__,
        models1.C新テーブル.__table__,  # 追加
    ]
)
```

**9. 初期データを追加（必要な場合） (`backend_server/crud1/init.py`)**

```python
def init_db_data(db: Session):
    # 既存の初期化処理...

    # C新テーブルの初期化
    if not db.query(models1.C新テーブル).first():
        初期データ = [
            ('001', '新データ1', '備考1'),
            ('002', '新データ2', '備考2'),
        ]
        認証情報 = {"利用者ID": "system", "利用者名": "system"}
        for 新ID, 新名, 新備考 in 初期データ:
            新テーブル = schemas.C新テーブルCreate(新ID=新ID, 新名=新名, 新備考=新備考)
            create_C新テーブル(db, 新テーブル, 認証情報)
        logger.info("Initialized C新テーブル")
```

**10. サーバー再起動**

```bash
# _start.pyを再起動（Ctrl+C → python _start.py）
# または
cd backend_server
.venv/Scripts/python.exe -m uvicorn main1:app --reload --host 0.0.0.0 --port 8091
```

**11. APIテスト**

- http://localhost:8091/docs にアクセス
- C新テーブル の各エンドポイントをテスト

#### M系/T系/S系テーブルの場合（main2.py）

上記の手順と同じですが、以下を置き換え：
- `models1` → `models2`
- `crud1` → `crud2`
- `routers1` → `routers2`
- `main1.py` → `main2.py`

### フロントエンド：新規CRUD画面の追加

#### 1. コンポーネントディレクトリ作成

```bash
mkdir -p frontend_server/src/components/C管理/C新テーブル
mkdir -p frontend_server/src/components/C管理/C新テーブル/components
```

#### 2. 一覧テーブルコンポーネント作成

**`frontend_server/src/components/C管理/C新テーブル/components/C新テーブル一覧テーブル.vue`**

```vue
<script setup lang="ts">
import { defineProps, defineEmits } from 'vue'
import qTubler from '@/components/_share/qTubler.vue'
import type { Column } from '@/types/qTubler'

defineProps<{
  items: any[]
}>()

const emit = defineEmits(['row-dblclick'])

const columns: Column[] = [
  { key: '新ID', label: '新ID', width: '150px', sortable: true },
  { key: '新名', label: '新名', width: '200px', sortable: true },
  { key: '新備考', label: '備考', width: '300px', sortable: true },
  { key: '更新日時', label: '更新日時', width: '180px', sortable: true },
]

const handleRowDblClick = (row: any) => {
  emit('row-dblclick', row)
}
</script>

<template>
  <qTubler
    :columns="columns"
    :data="items"
    :pageSize="20"
    @row-dblclick="handleRowDblClick"
  />
</template>
```

#### 3. 一覧画面作成

**`frontend_server/src/components/C管理/C新テーブル/C新テーブル一覧.vue`**

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import apiClient from '@/api/client'
import C新テーブル一覧テーブル from './components/C新テーブル一覧テーブル.vue'
import { qAlert } from '@/utils/qAlert'

const router = useRouter()
const items = ref<any[]>([])
const loading = ref(false)

const fetchItems = async () => {
  loading.value = true
  try {
    const response = await apiClient.post('/core/C新テーブル/一覧')
    if (response.data.status === 'OK') {
      items.value = response.data.data.items
    }
  } catch (error) {
    console.error(error)
    await qAlert('データの取得に失敗しました')
  } finally {
    loading.value = false
  }
}

const handleEdit = (row: any) => {
  router.push({ path: '/C管理/C新テーブル/編集', query: { 新ID: row.新ID } })
}

const handleNew = () => {
  router.push('/C管理/C新テーブル/編集')
}

onMounted(() => {
  fetchItems()
})
</script>

<template>
  <div class="page-container">
    <div class="page-header">
      <h1>C新テーブル一覧</h1>
      <button @click="handleNew" class="btn-primary">新規作成</button>
    </div>

    <div v-if="loading" class="loading">読込中...</div>

    <C新テーブル一覧テーブル
      v-else
      :items="items"
      @row-dblclick="handleEdit"
    />
  </div>
</template>

<style scoped>
.page-container {
  padding: 20px;
}

.page-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.btn-primary {
  padding: 10px 20px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.btn-primary:hover {
  background-color: #0056b3;
}

.loading {
  text-align: center;
  padding: 20px;
}
</style>
```

#### 4. 編集画面作成

**`frontend_server/src/components/C管理/C新テーブル/C新テーブル編集.vue`**

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import apiClient from '@/api/client'
import { qAlert, qConfirm } from '@/utils/qAlert'

const router = useRouter()
const route = useRoute()

const 新ID = ref('')
const 新名 = ref('')
const 新備考 = ref('')
const isNewMode = ref(true)

const fetchItem = async () => {
  const id = route.query.新ID as string
  if (!id) {
    isNewMode.value = true
    return
  }

  isNewMode.value = false
  try {
    const response = await apiClient.post('/core/C新テーブル/取得', { 新ID: id })
    if (response.data.status === 'OK') {
      const item = response.data.data
      新ID.value = item.新ID
      新名.value = item.新名
      新備考.value = item.新備考 || ''
    }
  } catch (error) {
    console.error(error)
    await qAlert('データの取得に失敗しました')
  }
}

const handleSave = async () => {
  if (!新ID.value || !新名.value) {
    await qAlert('必須項目を入力してください')
    return
  }

  try {
    const data = {
      新ID: 新ID.value,
      新名: 新名.value,
      新備考: 新備考.value || null
    }

    const endpoint = isNewMode.value ? '/core/C新テーブル/登録' : '/core/C新テーブル/変更'
    const response = await apiClient.post(endpoint, data)

    if (response.data.status === 'OK') {
      await qAlert(isNewMode.value ? '作成しました' : '更新しました')
      router.back()
    } else {
      await qAlert(`エラー: ${response.data.message}`)
    }
  } catch (error) {
    console.error(error)
    await qAlert('保存に失敗しました')
  }
}

const handleDelete = async () => {
  if (isNewMode.value) return

  const confirmed = await qConfirm('削除してもよろしいですか？')
  if (!confirmed) return

  try {
    const response = await apiClient.post('/core/C新テーブル/削除', { 新ID: 新ID.value })
    if (response.data.status === 'OK') {
      await qAlert('削除しました')
      router.back()
    } else {
      await qAlert(`エラー: ${response.data.message}`)
    }
  } catch (error) {
    console.error(error)
    await qAlert('削除に失敗しました')
  }
}

const handleCancel = () => {
  router.back()
}

onMounted(() => {
  fetchItem()
})
</script>

<template>
  <div class="page-container">
    <div class="page-header">
      <h1>{{ isNewMode ? 'C新テーブル 新規作成' : 'C新テーブル 編集' }}</h1>
    </div>

    <div class="form-container">
      <div class="form-group">
        <label>新ID <span class="required">*</span></label>
        <input v-model="新ID" :disabled="!isNewMode" type="text" class="form-control" />
      </div>

      <div class="form-group">
        <label>新名 <span class="required">*</span></label>
        <input v-model="新名" type="text" class="form-control" />
      </div>

      <div class="form-group">
        <label>備考</label>
        <textarea v-model="新備考" class="form-control" rows="3"></textarea>
      </div>

      <div class="button-group">
        <button @click="handleSave" class="btn-primary">保存</button>
        <button v-if="!isNewMode" @click="handleDelete" class="btn-danger">削除</button>
        <button @click="handleCancel" class="btn-secondary">キャンセル</button>
      </div>
    </div>
  </div>
</template>

<style scoped>
.page-container {
  padding: 20px;
}

.form-container {
  max-width: 600px;
  margin: 0 auto;
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

.required {
  color: red;
}

.form-control {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.button-group {
  display: flex;
  gap: 10px;
  margin-top: 30px;
}

.btn-primary, .btn-danger, .btn-secondary {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.btn-primary {
  background-color: #007bff;
  color: white;
}

.btn-danger {
  background-color: #dc3545;
  color: white;
}

.btn-secondary {
  background-color: #6c757d;
  color: white;
}
</style>
```

#### 5. ルート登録

**`frontend_server/src/router/index.ts`**

```typescript
// C新テーブル
{
  path: '/C管理/C新テーブル/一覧',
  name: 'C新テーブル一覧',
  component: () => import('../components/C管理/C新テーブル/C新テーブル一覧.vue'),
  meta: { requiresAuth: true, title: 'C新テーブル一覧' }
},
{
  path: '/C管理/C新テーブル/編集',
  name: 'C新テーブル編集',
  component: () => import('../components/C管理/C新テーブル/C新テーブル編集.vue'),
  meta: { requiresAuth: true, title: 'C新テーブル編集' }
},
```

#### 6. カテゴリメニューに追加

**`frontend_server/src/components/C管理.vue`**

```vue
<template>
  <div class="category-menu">
    <!-- 既存のカード... -->

    <div class="menu-card" @click="$router.push('/C管理/C新テーブル/一覧')">
      <h3>C新テーブル</h3>
      <p>新テーブルの管理</p>
    </div>
  </div>
</template>
```

---

## ベストプラクティス

### バックエンド

**1. 監査フィールドは必ず使用：**
```python
from crud1.utils import create_audit_fields, update_audit_fields

# ✅ 正解
監査項目 = create_audit_fields(認証情報)
db_item = Model(..., **監査項目)

# ❌ 誤り（手動で日時設定）
db_item = Model(..., 登録日時=datetime.now())
```

**2. エラーハンドリング：**
```python
@router.post("/登録")
def create_item(...):
    try:
        db_item = crud.create_item(db, item, 認証情報)
        db.commit()
        return ResponseBase(status="OK", message="作成しました", data=db_item)
    except Exception as e:
        db.rollback()
        logger.error(f"エラー: {e}")
        return ResponseBase(status="NG", message="エラーが発生しました", error={"detail": str(e)})
```

**3. 統一レスポンス形式：**
```python
# ✅ 正解
return schemas.ResponseBase(
    status="OK",
    message="取得しました",
    data={"items": items, "total": len(items), "limit": 10000}
)

# ❌ 誤り（独自フォーマット）
return {"success": True, "data": items}
```

### フロントエンド

**1. Composition API + script setup：**
```vue
<!-- ✅ 正解 -->
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'

const items = ref<any[]>([])
const loading = ref(false)

onMounted(() => {
  fetchItems()
})
</script>

<!-- ❌ 誤り（Options API） -->
<script>
export default {
  data() {
    return {
      items: [],
      loading: false
    }
  },
  mounted() {
    this.fetchItems()
  }
}
</script>
```

**2. qAlert/qConfirm の使用：**
```typescript
// ✅ 正解
import { qAlert, qConfirm } from '@/utils/qAlert'

await qAlert('保存しました')
const confirmed = await qConfirm('削除しますか？')

// ❌ 誤り（ネイティブダイアログ）
alert('保存しました')
const confirmed = confirm('削除しますか？')
```

**3. エラーハンドリング：**
```typescript
// ✅ 正解
try {
  const response = await apiClient.post('/core/C利用者/一覧')
  if (response.data.status === 'OK') {
    items.value = response.data.data.items
  } else {
    await qAlert(`エラー: ${response.data.message}`)
  }
} catch (error) {
  console.error(error)
  await qAlert('通信エラーが発生しました')
}

// ❌ 誤り（エラー処理なし）
const response = await apiClient.post('/core/C利用者/一覧')
items.value = response.data.data.items
```

---

## アンチパターン

### やってはいけないこと

**1. 平文パスワードの本番使用：**
```python
# ❌ 絶対ダメ（本番環境）
パスワード = "********"  # 平文保存

# ✅ 本番ではハッシュ化必須
from passlib.context import CryptContext
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
パスワードハッシュ = pwd_context.hash(パスワード)
```

**2. 日本語コンポーネントタグ：**
```vue
<!-- ❌ 絶対ダメ（無効） -->
<C利用者一覧 />

<!-- ✅ 動的コンポーネント使用 -->
<component :is="C利用者一覧" />
```

**3. GET/PUT/削除メソッドの使用：**
```python
# ❌ 誤り（このプロジェクトの規約違反）
@router.get("/一覧")
@router.put("/変更")
@router.delete("/削除")

# ✅ 正解（POST統一）
@router.post("/一覧")
@router.post("/変更")
@router.post("/削除")
```

**4. Database VIEWの作成：**
```python
# ❌ 誤り（このプロジェクトでは不使用）
CREATE VIEW V利用者 AS SELECT ...

# ✅ 正解（生SQLクエリ）
sql = "SELECT C利用者.*, C権限.権限名 FROM C利用者 LEFT JOIN C権限 ..."
result = db.execute(text(sql))
```

---

## デバッグ方法

### バックエンド

**1. FastAPI Swagger UI：**
```
http://localhost:8091/docs  (main1)
http://localhost:8092/docs  (main2)
```
- Authorize ボタンでトークン設定
- 各エンドポイントをテスト

**2. SQL ログ有効化：**
```python
# database.py
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False},
    echo=True  # SQL ログ出力
)
```

**3. Python デバッガー：**
```python
import pdb; pdb.set_trace()  # ブレークポイント
```

### フロントエンド

**1. Browser DevTools：**
- Network タブ: API リクエスト/レスポンス確認
- Console タブ: エラーログ確認
- Application タブ > Local Storage: JWT token 確認

**2. Vue DevTools：**
- Chrome拡張機能をインストール
- Piniaストアの状態確認
- コンポーネント階層確認

**3. console.log デバッグ：**
```typescript
console.log('items:', items.value)
console.log('response:', response.data)
```

---

## コードレビューのポイント

### チェックリスト

**バックエンド：**
- [ ] 全ファイルUTF-8エンコーディング
- [ ] 監査フィールド（登録/更新日時、利用者ID）が設定されている
- [ ] エラーハンドリング（try-catch, db.rollback）
- [ ] 統一レスポンス形式（ResponseBase）
- [ ] POST メソッド使用
- [ ] ログ出力（logger.info, logger.error）
- [ ] 日本語命名規約に従っている

**フロントエンド：**
- [ ] 全ファイルUTF-8エンコーディング
- [ ] script setup 使用（Composition API）
- [ ] qAlert/qConfirm 使用（ネイティブダイアログ不使用）
- [ ] エラーハンドリング（try-catch）
- [ ] qTubler 使用（統一テーブルUI）
- [ ] 日本語命名規約に従っている
- [ ] コンポーネントタグはASCII名

---

## まとめ

このドキュメントに従って開発することで：
- ✅ 統一されたコード品質
- ✅ 保守性の高いコードベース
- ✅ チーム開発のスムーズな連携
- ✅ 日本語ネイティブな開発体験

詳細な実装情報は各ドキュメントを参照してください：
- [backend_server/AGENTS.md](./backend_server/AGENTS.md)
- [frontend_server/AGENTS.md](./frontend_server/AGENTS.md)
- [AGENTS.md](./AGENTS.md)

